/**
 * Copyright (C) 2014  Universidade de Aveiro, DETI/IEETA, Bioinformatics Group - http://bioinformatics.ua.pt/
 *
 * This file is part of Dicoogle/dicoogle-sdk.
 *
 * Dicoogle/dicoogle-sdk is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Dicoogle/dicoogle-sdk is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Dicoogle.  If not, see <http://www.gnu.org/licenses/>.
 */
package pt.ua.dicoogle.sdk.datastructs.dim;

import pt.ua.dicoogle.sdk.mlprovider.MLlabel;

import java.util.Arrays;
import java.util.List;

/**
 * A bulk annotation object denotes a group of annotations from a DICOM file generated by third-party services like AI algorithms.
 * It follows the supplement 222 of the DICOM standard.
 * Annotations in a bulk annotation object share common attributes such as shape type, label, pixel origin, etc.
 */
public class BulkAnnotation {

    /**
     * Denotes the pixel origin of the annotations contained in this bulk.
     */
    public enum PixelOrigin {
        /**
         * Coordinates of this annotation are related to the frame (image section)
         */
        FRAME,
        /**
         * Coordinates of this annotation are related to the Frame Matrix (whole image)
         */
        VOLUME
    }

    /**
     * Denotes the type of annotations contained in this bulk.
     */
    public enum AnnotationType {
        RECTANGLE, ELLIPSE, POLYGON, POLYLINE, POINT
    }

    /**
     * Denotes the type of coordinates contained in this bulk
     */
    public enum CoordinateType {
        /**
         * For image relative coordinates
         */
        TWO_DIMENSIONAL,
        /**
         * For coordinates in a Cartesian system defined by a frame of reference
         */
        THREE_DIMENSIONAL
    }

    private PixelOrigin pixelOrigin;

    private CoordinateType coordinateType;

    private AnnotationType annotationType;

    private MLlabel label;

    private List<Point2D> points;

    private double confidence;

    public PixelOrigin getPixelOrigin() {
        return pixelOrigin;
    }

    public void setPixelOrigin(PixelOrigin pixelOrigin) {
        this.pixelOrigin = pixelOrigin;
    }

    public CoordinateType getCoordinateType() {
        return coordinateType;
    }

    public void setCoordinateType(CoordinateType coordinateType) {
        this.coordinateType = coordinateType;
    }

    public AnnotationType getAnnotationType() {
        return annotationType;
    }

    public void setAnnotationType(AnnotationType annotationType) {
        this.annotationType = annotationType;
    }

    public MLlabel getLabel() {
        return label;
    }

    public void setLabel(MLlabel label) {
        this.label = label;
    }

    public double getConfidence() {
        return confidence;
    }

    public void setConfidence(double confidence) {
        this.confidence = confidence;
    }

    public List<Point2D> getPoints() {
        return points;
    }

    public void setPoints(List<Point2D> points) {
        this.points = points;
    }


    /**
     * Calculate the bounding box of this annotation.
     * @return a list of 4 points, representing a rectangle that contains the provided annotation.
     */
    public List<Point2D> getBoundingBox(){

        double minX = Double.MAX_VALUE;
        double minY = Double.MAX_VALUE;
        double maxX = Double.MIN_VALUE;
        double maxY = Double.MIN_VALUE;

        switch (annotationType){
            case RECTANGLE:
                return this.getPoints();
            case POLYGON:
            case POLYLINE:
                for(Point2D p : this.getPoints()){
                    if(p.getX() > maxX)
                        maxX = p.getX();
                    if(p.getX() < minX)
                        minX = p.getX();

                    if(p.getY() > maxY)
                        maxY = p.getY();
                    if(p.getY() < minY)
                        minY = p.getY();
                }
                break;
            case ELLIPSE:
                minX = this.getPoints().get(0).getX();
                maxX = this.getPoints().get(1).getX();
                minY = this.getPoints().get(2).getY();
                maxY = this.getPoints().get(3).getY();
                break;
        }

        Point2D tl = new Point2D(minX, minY);
        Point2D tr = new Point2D(maxX, minY);
        Point2D bl = new Point2D(minX, maxY);
        Point2D br = new Point2D(maxX, maxY);

        return Arrays.asList(tl, tr, bl, br);
    }

    public double getArea(){
        List<Point2D> bbox = this.getBoundingBox();
        double width = bbox.get(1).getX() - bbox.get(0).getX();
        double height = bbox.get(0).getY() - bbox.get(2).getY();
        return Math.abs(width * height);
    }

}
